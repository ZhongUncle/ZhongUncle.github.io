<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv='content-language' content='zh-CN'>
        <title>APFS 文件系统探究</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="/assets/css/headerstyle.css" />
        <link rel="stylesheet" type="text/css" href="/assets/css/blogstyle.css" />
        <link rel="stylesheet" type="text/css" href="/assets/css/style.css" />
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>APFS 文件系统探究</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="APFS 文件系统探究" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="本文的创作初衷是因为我发现从底层详解 APFS 的资料很少，所以自己来进行了一些探究和整理。" />
<meta property="og:description" content="本文的创作初衷是因为我发现从底层详解 APFS 的资料很少，所以自己来进行了一些探究和整理。" />
<link rel="canonical" href="https://zhonguncle.github.io/blogs/ed2b91193eab92ce65c73ced7ac607d5.html" />
<meta property="og:url" content="https://zhonguncle.github.io/blogs/ed2b91193eab92ce65c73ced7ac607d5.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-14T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="APFS 文件系统探究" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-08-14T00:00:00+08:00","datePublished":"2023-08-14T00:00:00+08:00","description":"本文的创作初衷是因为我发现从底层详解 APFS 的资料很少，所以自己来进行了一些探究和整理。","headline":"APFS 文件系统探究","mainEntityOfPage":{"@type":"WebPage","@id":"https://zhonguncle.github.io/blogs/ed2b91193eab92ce65c73ced7ac607d5.html"},"url":"https://zhonguncle.github.io/blogs/ed2b91193eab92ce65c73ced7ac607d5.html"}</script>
<!-- End Jekyll SEO tag -->

        
        <!-- Microsoft Clarity -->
        <script type="text/javascript">
            (function(c,l,a,r,i,t,y){
                c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
                t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
                y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
            })(window, document, "clarity", "script", "ix8xlal10a");
        </script>

        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-SS87H0FDV7"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-SS87H0FDV7');
        </script>
    </head>
    <body>
        <div class="stackedit__html">
            <!-- 这个文件里是用来生成导航栏的 -->
<div class="header">
    
        <a href="/index.html" class="headerItem">
            主页
        </a>
    
        <a href="/swift.html" class="headerItem">
            Swift
        </a>
    
        <a href="/unix.html" class="headerItem">
            UNIX
        </a>
    
        <a href="/c.html" class="headerItem">
            C
        </a>
    
        <a href="/assembly.html" class="headerItem">
            Assembly
        </a>
    
        <a href="/go.html" class="headerItem">
            Go
        </a>
    
        <a href="/plan9.html" class="headerItem">
            Plan 9
        </a>
    
        <a href="/web.html" class="headerItem">
            Web
        </a>
    
        <a href="/mcu.html" class="headerItem">
            MCU
        </a>
    
        <a href="/research.html" class="headerItem">
            Research
        </a>
    
        <a href="/non-tech.html" class="headerItem">
            Non-Tech
        </a>
    
</div>
            <h1>APFS 文件系统探究</h1>
            <div class="bloginfo">
                <p class="info">2023-08-14 ｜ <a href="/research.html"> Research</a> ｜ 3225 字</p>
            </div>
            <!-- excerpt-start -->
<p>本文的创作初衷是因为我发现从底层详解 APFS 的资料很少，所以自己来进行了一些探究和整理。</p>

<h2 id="一点说明">一点说明</h2>
<p>如果你在看 APFS 的文档或者其他内容，不要把高层级的分区理解成 Windows 中的分区。因为 APFS 里卷（Volume）才是显示在“访达”中的，在硬盘和卷之间还有一个容器的概念，一个容器可以包含多个卷，这不好和 Windows 中的分区概念对应。</p>
<h2 id="apfs大致结构">APFS大致结构</h2>
<p>APFS 内部结构大致如下：</p>

<p><img src="/assets/images/8c1c047800b0450ebdb6b1c9795f0677.png" alt="APFS大致结构" /></p>

<p>上图只有一个卷，然后描述了这个卷中的各部分信息。其中“Storage for objects and file data”中的“objects”就包含了我们在访达中看到的那个存储硬盘，也就是一个卷。</p>

<p>“GUID partition table”的缩写便是很多人在 Windows 上熟知的 GPT（不是那个聊天机器人），而 GPT 分区则是 EFI 技术的一部分（EFI 又名为 UEFI，是 Intel 发明的）。</p>

<p>APFS 的每个容器是按照顺序排列在硬盘里的，并不会有空隙，这与 Windows 的 GPT 分区不一样。</p>

<p><img src="/assets/images/00314bd8c51c4bce976482d02460c70f.png" alt="APFS 的空闲空间是在各个卷之间共同分享的，所以扩展起来很容易" /></p>

<p>这也是为什么 Windows 上你只能扩展或调整最后一个分区的大小，而不能调整前面的盘（APFS 的空闲空间是在各个卷之间共同分享的，所以扩展起来很容易，如下图）。以及为什么 macOS 上新建 APFS 分区的时候需要很久很久（因为要把其他分区的文件挪到合适的地方）。</p>

<p>但系统是怎么知道硬盘上有这个容器的呢？顺序读取的话，第一个容器按顺序读下去就行了，但是第二个呢？</p>

<p>首先，系统不是通过顺序读取来发现容器的。而这些工作是硬盘最开始的 GUID partition table 的任务了，这部分会包含各个分区的起始和终止地址，用的时候跳转就行了，是一种目录式的结构。如下图（源自官方标准<a href="https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html">《GUID Partition Table (GPT) Disk Layout》</a>）：
<img src="/assets/images/faee30b2b1ce43ebb878cf971debbac1.png" alt="https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html" /></p>

<p>可以看到通过主要分区表或者备用分区表划分分区以及进行跳转。</p>

<p>如果你查看 APFS 格式硬盘的十六进制的话，就可以看到如下情况（需要注意“GPT Header”部分是从<code class="language-plaintext highlighter-rouge">200</code>那行开始的）：</p>

<p><img src="/assets/images/4fb95fe4da7f4da5abde04e356b4b3e5.png" alt="请添加图片描述" /></p>

<p>可以看到内部开头的结构与其他 UEFI 格式的差不多。</p>

<h3 id="protective-mbr">Protective MBR</h3>
<p>APFS 与其他一些 GPT 分区的文件系统不同的是：不论是不是启动盘，都会有 Protective MBR 部分。</p>

<p>Protective MBR 必须是使用 GPT 分区的硬盘上第一个逻辑块。这个分区的存在使得计算机认为这个硬盘是可以使用的，并且已被使用，就不会弹出弹窗问你需不需要进行分区、格式化等操作，EFI 本身是不会使用这个块的。</p>

<p>Protective MBR 部分如下：
<img src="/assets/images/2f223bf420de4a769ea16205900ef73c.png" alt="请添加图片描述" /></p>

<p>各部分内容含义如下（偏移量是从这部分开头开始算，而且也是十六进制的）：</p>

<table>
  <thead>
    <tr>
      <th>部分</th>
      <th>字节偏移量</th>
      <th>字节长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>启动码</td>
      <td>0</td>
      <td>440</td>
      <td>EFI不会使用这部分，<code class="language-plaintext highlighter-rouge">440</code>的十六进制就是<code class="language-plaintext highlighter-rouge">1b8</code>，所以可以看到上图中<code class="language-plaintext highlighter-rouge">1b8</code>和之前的部分全部是<code class="language-plaintext highlighter-rouge">00</code></td>
    </tr>
    <tr>
      <td>唯一MBR硬盘签名</td>
      <td>440</td>
      <td>4</td>
      <td>没有被使用，设置为<code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td>未知</td>
      <td>444</td>
      <td>2</td>
      <td>没有被使用，设置为<code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
    <tr>
      <td>分区记录</td>
      <td>446</td>
      <td>16*4</td>
      <td>四个MBR分区记录的数组。MBR最多就 4 个分区。</td>
    </tr>
    <tr>
      <td>签名</td>
      <td>510</td>
      <td>2</td>
      <td>设置为<code class="language-plaintext highlighter-rouge">0xAA55</code>，也就是图中的<code class="language-plaintext highlighter-rouge">1f0</code>那行最后的<code class="language-plaintext highlighter-rouge">55 aa</code></td>
    </tr>
    <tr>
      <td>保留块</td>
      <td>512</td>
      <td>逻辑块大小-512</td>
      <td>逻辑块的剩余保留部分，设置为<code class="language-plaintext highlighter-rouge">0</code></td>
    </tr>
  </tbody>
</table>

<p>如果你对上面左侧的序号有疑问，需要记住这是十六进制的。比如说，最后的<code class="language-plaintext highlighter-rouge">512</code>的十六进制便是<code class="language-plaintext highlighter-rouge">200</code>。</p>
<h3 id="gpt-header">GPT Header</h3>
<p>GPT Header 是 UEFI 技术和 GPT 分区的核心部分，这部分存储了很多信息。GPT Header 各部分如下：</p>

<p><img src="/assets/images/edd3264d7bbd468eab207b8a36803d7c.png" alt="请添加图片描述" /></p>

<p>各部分内容含义如下（偏移量是从这部分开头开始算）：</p>

<table>
  <thead>
    <tr>
      <th>部分</th>
      <th>字节偏移量</th>
      <th>字节长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>签名</td>
      <td>0</td>
      <td>8</td>
      <td>这部分是 ASCII 格式的字符串“EFI PART”，用 64 位编码，也就是上图中的<code class="language-plaintext highlighter-rouge">45 46 49 20 50 41 52 54</code></td>
    </tr>
    <tr>
      <td>修正版本</td>
      <td>8</td>
      <td>4</td>
      <td>GPT Header 的修正版本数，这个版本不等于 UEFI 指定版本。上文中的<code class="language-plaintext highlighter-rouge">00 00 01 00</code>表示是版本 1.0</td>
    </tr>
    <tr>
      <td>Header 尺寸</td>
      <td>12</td>
      <td>4</td>
      <td>GPT Header 的尺寸，单位是字节。这部分必须大于等于 92，小于等于逻辑块大小。上面的<code class="language-plaintext highlighter-rouge">5C 00 00 00</code>表示 92 个字节，也就是最小尺寸。上图只有 60 个字节，是因为省略了最后的几个空行</td>
    </tr>
    <tr>
      <td>Header的CRC32</td>
      <td>16</td>
      <td>4</td>
      <td>GPT Header 结构的 CRC32 校验和。先将这个值设置为 0，然后计算 GPT Header 结构的 32 位 CRC32 校验和，这里的校验和是<code class="language-plaintext highlighter-rouge">15 51 0f ff</code></td>
    </tr>
    <tr>
      <td>保留部分</td>
      <td>20</td>
      <td>4</td>
      <td>这部分必须全部为 0</td>
    </tr>
    <tr>
      <td>MyLBA部分</td>
      <td>24</td>
      <td>8</td>
      <td>这个 LBA（逻辑块地址）包含数据结构，验证 GPT 的时候会检查 MyLBA 实例指向的 GUID Partition Table 中的 LBA，上图中为<code class="language-plaintext highlighter-rouge">01 00 00 00 00 00 00 00</code></td>
    </tr>
    <tr>
      <td>AlternateLBA</td>
      <td>32</td>
      <td>8</td>
      <td>备用 GPT Header 的 LBA 地址，上图中为<code class="language-plaintext highlighter-rouge">ff ff bf 46 07 00 00 00</code></td>
    </tr>
    <tr>
      <td>第一个可使用LBA</td>
      <td>40</td>
      <td>8</td>
      <td>GUID Partition Entry描述的一个分区的第一个被使用的可使用逻辑块，上图中为<code class="language-plaintext highlighter-rouge">22 00 00 00 00 00 00 00</code></td>
    </tr>
    <tr>
      <td>最后一个可使用</td>
      <td>48</td>
      <td>8</td>
      <td>GUID Partition Entry描述的一个分区的最后一个被使用的可使用逻辑块，上图中为<code class="language-plaintext highlighter-rouge">de ff bf 46 07 00 00 00</code></td>
    </tr>
    <tr>
      <td>硬盘GUID</td>
      <td>56</td>
      <td>16</td>
      <td>标识硬盘的 GUID，上图中为<code class="language-plaintext highlighter-rouge">84 ec 00 4a 8e 8c fd 47 8a 78 25 48 bf a4 90 99</code></td>
    </tr>
    <tr>
      <td>分区实例 LBA</td>
      <td>72</td>
      <td>8</td>
      <td>GUID分区实例数组的开始 LBA，上图中为<code class="language-plaintext highlighter-rouge">02 00 00 00 00 00 00 00</code></td>
    </tr>
    <tr>
      <td>分区实例的数量</td>
      <td>80</td>
      <td>4</td>
      <td>GUID分区实例数组中分区实例的数量，上图中为<code class="language-plaintext highlighter-rouge">80 00 00 00</code>，也就是 8 个</td>
    </tr>
    <tr>
      <td>分区实例的尺寸</td>
      <td>84</td>
      <td>4</td>
      <td>GUID分区实例数组中GUID分区实例结构体的尺寸，这部分应该设置成<code class="language-plaintext highlighter-rouge">128 x 2n</code>的大小，<code class="language-plaintext highlighter-rouge">n</code>是大于等于<code class="language-plaintext highlighter-rouge">0</code>的整数，这部分一般是 128、256 等，但是早期的版本允许<code class="language-plaintext highlighter-rouge">8</code>的任意倍数。上图中的<code class="language-plaintext highlighter-rouge">80 00 00 00</code>实际上就是十六进制的<code class="language-plaintext highlighter-rouge">80</code>，也就是 128 个字节</td>
    </tr>
    <tr>
      <td>分区实例数组的CRC32</td>
      <td>88</td>
      <td>4</td>
      <td>GUID分区实例数组的 CRC32</td>
    </tr>
    <tr>
      <td>保留</td>
      <td>92</td>
      <td>剩下所有</td>
      <td>保留块，全部为 0</td>
    </tr>
  </tbody>
</table>

<h3 id="gpt-partition-entry-array">GPT Partition Entry Array</h3>
<p>GPT 分区实例数组（GPT Partition Entry Array）包含一个数组，这个数组存储了 GPT 分区实例。依旧先说明每个部分是什么，下面是 GPT 分区实例数组中的第一个实例：</p>

<p><img src="/assets/images/960f0ac0ee3844c7bfe68fe4aae955bf.png" alt="请添加图片描述" /></p>

<table>
  <thead>
    <tr>
      <th>部分</th>
      <th>字节偏移量</th>
      <th>字节长度</th>
      <th>内容</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>分区类型 GUID</td>
      <td>0</td>
      <td>16</td>
      <td>定义分区目标和类型的唯一ID。如果分区没有被使用，那么这部分为 0。上图中为：<code class="language-plaintext highlighter-rouge">28 73 2a c1 1f f8 d2 11 ba 4b 00 a0 c9 3e c9 3b</code>，关于这部分的每个比特背后的含义后面细说</td>
    </tr>
    <tr>
      <td>唯一分区 GUID</td>
      <td>16</td>
      <td>16</td>
      <td>每个分区实例唯一的 GUID。每个分区被创建时都会有这样一个唯一的 GUID，这个 GUID 也必须在 GPT 分区实例创建时分配值。上图中分配的为<code class="language-plaintext highlighter-rouge">f8 56 1c 99 8d 6f 9e 4f bb fa 01 ca 52 57 cc 05</code></td>
    </tr>
    <tr>
      <td>起始 LBA</td>
      <td>32</td>
      <td>8</td>
      <td>这个实例中定义的分区起始 LBA</td>
    </tr>
    <tr>
      <td>终点 LBA</td>
      <td>40</td>
      <td>8</td>
      <td>这个实例中定义的分区终点 LBA</td>
    </tr>
    <tr>
      <td>属性</td>
      <td>48</td>
      <td>8</td>
      <td>这些属性位全部被 UEFI 保留，所以这里全部都是<code class="language-plaintext highlighter-rouge">00 00 00 00 00 00 00 00</code></td>
    </tr>
    <tr>
      <td>分区名称</td>
      <td>56</td>
      <td>72</td>
      <td>一个包含人类可读名称的无终止符字符。由于这是一个 EFI 分区，所以显示的是<code class="language-plaintext highlighter-rouge">EFI System Partition</code></td>
    </tr>
    <tr>
      <td>保留区域</td>
      <td>128</td>
      <td>之前设置的大小 ～ 128</td>
      <td>这部分必须为 0</td>
    </tr>
  </tbody>
</table>

<p>根据操作系统的不同、分区的不同，分区类型 GUID 的值也是不同的。比如说上面的这个 EFI 系统分区的 GUID 值就是<code class="language-plaintext highlighter-rouge">28 73 2a c1 1f f8 d2 11 ba 4b 00 a0 c9 3e c9 3b</code>。有时你在其他资料里会看到是这样的：<code class="language-plaintext highlighter-rouge">C12A7328-F81F-11D2-BA4B-00A0C93EC93B</code>，这里每个<code class="language-plaintext highlighter-rouge">-</code>分隔开每个部分，加之上图中的值为小端数，你可以对应看看是一样的。</p>

<p>而 APFS 分区的分区类型 GUID 是<code class="language-plaintext highlighter-rouge">ef 57 34 7c 00 00 aa 11 aa 11 00 30 65 43 ec ac</code>，或者说<code class="language-plaintext highlighter-rouge">7C3457EF-0000-11AA-AA11-00306543ECAC</code></p>

<p>上面“属性”中每部分的含义如下：</p>

<table>
  <thead>
    <tr>
      <th>位</th>
      <th>名称</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>请求分区</td>
      <td>如果设置了这一位，那么必须有这个分区才能使平台运行，删除或修改这个分区的内容可能会导致平台功能丢失、无法启动或运行。所以除非操作系统、软件或固件能识别这个分区，否则不应该删除或修改这个分区。</td>
    </tr>
    <tr>
      <td>1</td>
      <td>没有块IO传输协议</td>
      <td>如果设置了此位，那么固件不能为此分区生成EFI_BLOCK_IO_PROTOCOL部分，不设置这部分，那么就不会在 UEFI 中为该分区创建文件系统的映射</td>
    </tr>
    <tr>
      <td>2</td>
      <td>传统 BIOS 可启动</td>
      <td>这位留给具有传统 PC-AT BIOS 固件的系统实现通知特定受限的、特殊目标的软件运行在一个可用 GPT 分区启动的系统上</td>
    </tr>
    <tr>
      <td>3～47</td>
      <td> </td>
      <td>未定义，必须为 0，保留给未来的 UEFI 规范的扩展</td>
    </tr>
    <tr>
      <td>48～63</td>
      <td> </td>
      <td>保留给 GUID 特定用途使用。这些位的使用根据分区类型 GUID 而设定。如果修改了 0～47 位中的任何一位，那么都必须保留这些位</td>
    </tr>
  </tbody>
</table>

<p>可以看到，在 GPT 分区实例数组中的每个实例中，都标出了起始和终止点，于是就通过这些部分进行跳转和获取。</p>
<h2 id="参考资料和扩展阅读">参考资料和扩展阅读</h2>

<p>如果你想尝试查看上面的内容，那么可以按照我的这篇博客进行操作：<a href="https://zhonguncle.github.io/blogs/5818e6378b56f7e45cb9f37b6c780659.html">《如何在Mac终端上，从底层按照字节用十六进制查看某个硬盘的内容（使用dd和hexdump实现winhex的功能，所以其他系统也可以使用这个方法）》</a>。</p>

<p>关于 APFS 格式的实现细节可以参阅苹果对这篇文档：<a href="https://developer.apple.com/support/downloads/Apple-File-System-Reference.pdf">《Apple File System Reference》</a>（“Apple File System”就是 APFS 的全称）。</p>

<p>UEFI 官方文档为：<a href="https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html">《GUID Partition Table (GPT) Disk Layout》</a>。</p>

<p>《数据恢复技术深度揭秘（第二版）》刘伟编著。</p>

<p>希望能帮到有需要的人～</p>

        </div>
    </body>
</html>