<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv='content-language' content='zh-CN'>
        <title>《自学考试数据库课程实践作业》 A802-钟宜江</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="/assets/css/headerstyle.css" />
        <link rel="stylesheet" type="text/css" href="/assets/css/blogstyle.css" />
        <link rel="stylesheet" type="text/css" href="/assets/css/style.css" />
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>《自学考试数据库课程实践作业》 A802-钟宜江</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="《自学考试数据库课程实践作业》 A802-钟宜江" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="总体设计 根据题目要求，使用 C 语言制作了一个 CLI 程序来对单向链表进行如下操作，并且分析了每个操作的工作原理： 创建一条含正整数结点的无序链表：根据用户输入从零创建一个新的链表，包括头节点head。用户每次输入完都会显示当前链表的内容。 链表结点的输出：使用printf()格式化输出head后所有节点的值到标准输出（stdout）中，默认情况下会打印到终端上。要考虑到链表为空的情况，这种情况应该提示用户链表为空。 链表结点的升序排序：选出所有节点中最小的，然后与head后到第一个节点交换，以此类推，直到没有节点再需要交换。按照《The Art of Computer Programming》第三卷中的定义和描述（73页），交换、插入和选择这三种排序的边界并不总是很明确的（105页），所以这种算法应该算是一种交换排序，但是又有插入排序的感觉。复杂度大致为O(n^2)。 链表结点插入：这个操作默认了链表是顺序的，插入后也应该是顺序的，所以插入节点需要考虑到插入位置，在开头、中间、结尾的方法是不一样的。 链表结点删除：删除节点只需要匹配相等的值即可，需要注意不能匹配到一个合适的值就结束，因为如果链表是有序的，那么可能会有几个连续的值；如果是无序的，那么可能会在后面有相同的值。 链表逆序（升序变降序）：就是将后续的值不断插入到head和head-&gt;next这两个节点之间即可。 链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表：通过值来判断是奇数节点还是偶数节点。拆分之后分别输出到标准输出，默认情况下会打印到终端上。 释放链表：使用free()来释放分配给节点的空间，释放后“链表结点的输出”的结果应该为空。" />
<meta property="og:description" content="总体设计 根据题目要求，使用 C 语言制作了一个 CLI 程序来对单向链表进行如下操作，并且分析了每个操作的工作原理： 创建一条含正整数结点的无序链表：根据用户输入从零创建一个新的链表，包括头节点head。用户每次输入完都会显示当前链表的内容。 链表结点的输出：使用printf()格式化输出head后所有节点的值到标准输出（stdout）中，默认情况下会打印到终端上。要考虑到链表为空的情况，这种情况应该提示用户链表为空。 链表结点的升序排序：选出所有节点中最小的，然后与head后到第一个节点交换，以此类推，直到没有节点再需要交换。按照《The Art of Computer Programming》第三卷中的定义和描述（73页），交换、插入和选择这三种排序的边界并不总是很明确的（105页），所以这种算法应该算是一种交换排序，但是又有插入排序的感觉。复杂度大致为O(n^2)。 链表结点插入：这个操作默认了链表是顺序的，插入后也应该是顺序的，所以插入节点需要考虑到插入位置，在开头、中间、结尾的方法是不一样的。 链表结点删除：删除节点只需要匹配相等的值即可，需要注意不能匹配到一个合适的值就结束，因为如果链表是有序的，那么可能会有几个连续的值；如果是无序的，那么可能会在后面有相同的值。 链表逆序（升序变降序）：就是将后续的值不断插入到head和head-&gt;next这两个节点之间即可。 链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表：通过值来判断是奇数节点还是偶数节点。拆分之后分别输出到标准输出，默认情况下会打印到终端上。 释放链表：使用free()来释放分配给节点的空间，释放后“链表结点的输出”的结果应该为空。" />
<link rel="canonical" href="http://localhost:4000/blogs/1234.html" />
<meta property="og:url" content="http://localhost:4000/blogs/1234.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-09-25T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="《自学考试数据库课程实践作业》 A802-钟宜江" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-25T00:00:00+08:00","datePublished":"2022-09-25T00:00:00+08:00","description":"总体设计 根据题目要求，使用 C 语言制作了一个 CLI 程序来对单向链表进行如下操作，并且分析了每个操作的工作原理： 创建一条含正整数结点的无序链表：根据用户输入从零创建一个新的链表，包括头节点head。用户每次输入完都会显示当前链表的内容。 链表结点的输出：使用printf()格式化输出head后所有节点的值到标准输出（stdout）中，默认情况下会打印到终端上。要考虑到链表为空的情况，这种情况应该提示用户链表为空。 链表结点的升序排序：选出所有节点中最小的，然后与head后到第一个节点交换，以此类推，直到没有节点再需要交换。按照《The Art of Computer Programming》第三卷中的定义和描述（73页），交换、插入和选择这三种排序的边界并不总是很明确的（105页），所以这种算法应该算是一种交换排序，但是又有插入排序的感觉。复杂度大致为O(n^2)。 链表结点插入：这个操作默认了链表是顺序的，插入后也应该是顺序的，所以插入节点需要考虑到插入位置，在开头、中间、结尾的方法是不一样的。 链表结点删除：删除节点只需要匹配相等的值即可，需要注意不能匹配到一个合适的值就结束，因为如果链表是有序的，那么可能会有几个连续的值；如果是无序的，那么可能会在后面有相同的值。 链表逆序（升序变降序）：就是将后续的值不断插入到head和head-&gt;next这两个节点之间即可。 链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表：通过值来判断是奇数节点还是偶数节点。拆分之后分别输出到标准输出，默认情况下会打印到终端上。 释放链表：使用free()来释放分配给节点的空间，释放后“链表结点的输出”的结果应该为空。","headline":"《自学考试数据库课程实践作业》 A802-钟宜江","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blogs/1234.html"},"url":"http://localhost:4000/blogs/1234.html"}</script>
<!-- End Jekyll SEO tag -->

    </head>
    <body>
        <div class="stackedit__html">
            <h1>《自学考试数据库课程实践作业》 A802-钟宜江</h1>
            <div class="bloginfo">
                <p class="info">2022-09-25 ｜ 5310 字</p>
            </div>
            <h2 id="总体设计">总体设计</h2>
<p>根据题目要求，使用 C 语言制作了一个 CLI 程序来对单向链表进行如下操作，并且分析了每个操作的工作原理：</p>
<ol>
  <li><strong>创建一条含正整数结点的无序链表</strong>：根据用户输入从零创建一个新的链表，包括头节点<code class="language-plaintext highlighter-rouge">head</code>。用户每次输入完都会显示当前链表的内容。</li>
  <li><strong>链表结点的输出</strong>：使用<code class="language-plaintext highlighter-rouge">printf()</code>格式化输出<code class="language-plaintext highlighter-rouge">head</code>后所有节点的值到标准输出（stdout）中，默认情况下会打印到终端上。要考虑到链表为空的情况，这种情况应该提示用户链表为空。</li>
  <li><strong>链表结点的升序排序</strong>：选出所有节点中最小的，然后与<code class="language-plaintext highlighter-rouge">head</code>后到第一个节点交换，以此类推，直到没有节点再需要交换。按照《The Art of Computer Programming》第三卷中的定义和描述（73页），交换、插入和选择这三种排序的边界并不总是很明确的（105页），所以这种算法应该算是一种交换排序，但是又有插入排序的感觉。复杂度大致为<code class="language-plaintext highlighter-rouge">O(n^2)</code>。</li>
  <li><strong>链表结点插入</strong>：这个操作默认了链表是顺序的，插入后也应该是顺序的，所以插入节点需要考虑到插入位置，在开头、中间、结尾的方法是不一样的。</li>
  <li><strong>链表结点删除</strong>：删除节点只需要匹配相等的值即可，需要注意不能匹配到一个合适的值就结束，因为如果链表是有序的，那么可能会有几个连续的值；如果是无序的，那么可能会在后面有相同的值。</li>
  <li><strong>链表逆序（升序变降序）</strong>：就是将后续的值不断插入到<code class="language-plaintext highlighter-rouge">head</code>和<code class="language-plaintext highlighter-rouge">head-&gt;next</code>这两个节点之间即可。</li>
  <li><strong>链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表</strong>：通过值来判断是奇数节点还是偶数节点。拆分之后分别输出到标准输出，默认情况下会打印到终端上。</li>
  <li><strong>释放链表</strong>：使用<code class="language-plaintext highlighter-rouge">free()</code>来释放分配给节点的空间，释放后“链表结点的输出”的结果应该为空。</li>
</ol>

<p>将每一个操作写成一个函数，这样可以很方便地通过<code class="language-plaintext highlighter-rouge">switch</code>来选择使用哪个操作，某些函数还需要互相调用。</p>

<h2 id="开发环境">开发环境</h2>
<ul>
  <li>系统：macOS 12.6.6</li>
  <li>编译器：Apple clang version 14.0.0 (clang-1400.0.29.202)</li>
</ul>

<h2 id="编译流程">编译流程</h2>
<p>虽然使用 macOS 作为开发平台，但是由于只使用了 C 标准库，也并没有涉及特定的系统调用、库，所以可以在任意 Unix-Like 系统（如 Ubuntu、FreeBSD、WSL）上使用<code class="language-plaintext highlighter-rouge">clang</code>或<code class="language-plaintext highlighter-rouge">gcc</code>进行编译。</p>

<p>编译命令如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 使用gcc
$ gcc linkedList.c
# 使用clang
$ cc linkedList.c
</code></pre></div></div>

<p>实测在 Ubuntu、FreeBSD 上都可以进行正常编译和运行（不过 FreeBSD 可能会中文显示乱码）。</p>

<h2 id="运行效果">运行效果</h2>
<p>下面展示程序在多种情况下的运行效果。截图为 macOS，但是其他平台效果也是一样的。</p>

<h3 id="1-创建一条含正整数结点的无序链表">1. 创建一条含正整数结点的无序链表</h3>
<p>用户输入<code class="language-plaintext highlighter-rouge">1</code>之后会进入创建链表模式。进入创建模式之后，会根据输入的值新建一个节点，并且连接到链表的最后一个节点。输入<code class="language-plaintext highlighter-rouge">-1</code>会退出创建模式。</p>

<p>下面是新建一个内容为<code class="language-plaintext highlighter-rouge">3 2 4 5 1</code>的链表的过程：</p>

<p><img alt="" src="/tempImage/1.png" style="box-shadow: 0px 0px 0px 0px" /></p>

<h3 id="2-链表结点的输出">2. 链表结点的输出</h3>
<p>这个操作的运行效果其实上面已经见过了，如下是显示上面新建链表的内容：</p>

<p><img src="/tempImage/2.png" alt="" /></p>

<p>可以看到结果和上一个操作最后显示的是一样的，并且没有新建最后为了退出而输入的<code class="language-plaintext highlighter-rouge">-1</code>的节点。</p>

<h3 id="3-链表结点的升序排序">3. 链表结点的升序排序</h3>
<p>这个操作会使用交换排序算法来对链表进行排序，结果为增序。</p>

<p>对前面新建链表进行增序排序，并且使用<code class="language-plaintext highlighter-rouge">2</code>来检查链表内容是否排序正确，如下：</p>

<p><img alt="" src="/tempImage/3.png" style="box-shadow: 0px 0px 0px 0px" /></p>

<h3 id="4-链表结点插入">4. 链表结点插入</h3>
<p>由于插入前后链表都应该是顺序的，所以插入的位置需要判断和处理，下面是三种不同情况插入结果。</p>

<p>当前链表内容为<code class="language-plaintext highlighter-rouge">1 2 3 4 5</code>，如果要插入到开头的话，那么应该插入<code class="language-plaintext highlighter-rouge">0</code>或<code class="language-plaintext highlighter-rouge">1</code>，但是为了检查是否能正确插入一个当前已经存在的节点，所以就选择<code class="language-plaintext highlighter-rouge">1</code>，如下：</p>

<p><img src="/tempImage/4.png" alt="" /></p>

<p>当前链表内容为<code class="language-plaintext highlighter-rouge">1 1 2 3 4 5</code>，为了检验是否可以正确插入到中间位置，这里选择<code class="language-plaintext highlighter-rouge">3</code>，如下：</p>

<p><img src="/tempImage/5.png" alt="" /></p>

<p>当前链表内容为<code class="language-plaintext highlighter-rouge">1 1 2 3 3 4 5</code>，为了检验是否可以正确插入到末尾位置，这里选择<code class="language-plaintext highlighter-rouge">5</code>，如下：</p>

<p><img src="/tempImage/6.png" alt="" /></p>

<h3 id="5-链表结点删除">5. 链表结点删除</h3>
<p>这个操作会删除链表中的某个值的节点。这个同样需要考虑不同位置情况，但是又更复杂了一些：要考虑到链表中这个值可能有多个节点，而且链表并不一定是有序的，也就是说同样值的节点并不一定是连续的。</p>

<p>所以专门设计一个链表，只需要一个测试就可以测试三个位置和多个连续或不连续同样的值的节点的情况。</p>

<p>新建一个链表，内容为<code class="language-plaintext highlighter-rouge">1 1 2 1 1 3 1 1</code>，进行删除<code class="language-plaintext highlighter-rouge">1</code>的操作后，链表的内容应该<code class="language-plaintext highlighter-rouge">2 3</code>。</p>

<p>实际情况如下：</p>

<p><img alt="" src="/tempImage/7.png" style="box-shadow: 0px 0px 0px 0px" /></p>

<h3 id="6-链表逆序升序变降序">6. 链表逆序（升序变降序）</h3>
<p>根据题意，这里使用的链表肯定是有序的，还得是增序，但是不能使用排序算法，而是插入的方法。</p>

<p>为了测试程序，这里有三个链表进行测试：<code class="language-plaintext highlighter-rouge">1</code>、<code class="language-plaintext highlighter-rouge">1 2</code>和<code class="language-plaintext highlighter-rouge">1 2 3 4 5</code>。前两个是为了测试特殊情况下程序是否能正常运行，第三个则是检查排序是否正确。</p>

<p>内容为<code class="language-plaintext highlighter-rouge">1</code>的链表结果如下：</p>

<p><img src="/tempImage/8.png" alt="" /></p>

<p>内容为<code class="language-plaintext highlighter-rouge">1 2</code>的链表结果如下：</p>

<p><img src="/tempImage/9.png" alt="" /></p>

<p>内容为<code class="language-plaintext highlighter-rouge">1 2 3 4 5</code>的链表结果如下：</p>

<p><img src="/tempImage/10.png" alt="" /></p>

<p>可以看到都正确运行了。</p>

<h3 id="7-链表拆分将链表拆分成由奇数和偶数结点组成的两条链表">7. 链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表</h3>
<p>下面对上面最后的链表<code class="language-plaintext highlighter-rouge">5 4 3 2 1</code>进行拆分，并且分别打印出奇书节点和偶数节点组成的链表：</p>

<p><img src="/tempImage/11.png" alt="" /></p>

<h3 id="8-释放链表">8. 释放链表</h3>
<p>使用<code class="language-plaintext highlighter-rouge">free()</code>来释放分配给节点的空间，释放后“链表结点的输出”的结果应该为空。</p>

<p>下面对内容为<code class="language-plaintext highlighter-rouge">1 2 3 4 5</code>的链表进行该操作，如下：</p>

<p><img alt="" src="/tempImage/12.png" style="box-shadow: 0px 0px 0px 0px" /></p>

<p>可以看到链表被清空了。</p>

<h2 id="源代码">源代码</h2>
<p>下面是源代码，并对一些代码进行了注释：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">printMenu</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">createNode</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">printLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">sortLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">insertNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">reverseNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">oddEvenDivide</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">freeLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="cm">/* 如果不在这分配空间进行初始化，那么链表头节点是在 createNode() 函数中创建和初始化的
       但是在这种情况下，如果用户直接打印链表会由于访问无效地址而导致程序出现错误 */</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">sel</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printMenu</span><span class="p">();</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sel</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">head</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">();</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">sortLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">insertNode</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">deleteNode</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">reverseNode</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">oddEvenDivide</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">freeLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"输入序号错误！</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"程序结束</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printMenu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"1. 创建一条含正整数结点的无序链表</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"2. 链表结点的输出</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"3. 链表结点的升序排序</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"4. 链表结点插入</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"5. 链表结点删除</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"6. 链表逆序（升序变降序）</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"7. 链表拆分，将链表拆分成由奇数和偶数结点组成的两条链表</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"8. 释放链表</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"0. 退出</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"请输入序号: "</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Node</span><span class="o">*</span> <span class="nf">createNode</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"下一个链表节点值为(输入“-1”表示结束): "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
    <span class="c1">//如果第一个值就为-1，那么直接退出</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//首个节点的建立，p2是第一个建立的节点的同时，也是指向链表最后一个节点的指针</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
        <span class="n">p2</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        
        <span class="c1">//中间节点的插入</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"下一个链表节点值为(输入“-1”表示结束): "</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
            <span class="n">p1</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>
            <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
            <span class="n">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"下一个链表节点值为(输入“-1”表示结束): "</span><span class="p">);</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//尾节点的处理</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">printLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为空</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为: "</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sortLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为空，无法排序</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">start</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">min</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">min</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">start</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">min</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">min</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insertNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">insertNum</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"请输入插入的节点值: "</span><span class="p">);</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insertNum</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">insertNode</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
    <span class="n">insertNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">insertNum</span><span class="p">;</span>
    
    <span class="c1">//如果是空链表</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">insertNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pre</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">insertNum</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">insertNum</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//如果插入位置在开头</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">insertNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">insertNode</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">//如果在不在最后一个节点的话，那么多下面这个语句</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">insertNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">insertNode</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//如果是空链表</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"链表为空，没有可以删除的节点"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">deleteNum</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"请需要删除节点的值: "</span><span class="p">);</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">deleteNum</span><span class="p">);</span>
        <span class="c1">//如果第一个节点就是需要删除的，那么需要单独处理</span>
        <span class="c1">//需要循环是为了处理起始的几个节点值是一样的情况，不然只会删除第一个</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">deleteNum</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">deleteNum</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">//这里没有使用else是因为链表不一定是排序好的，考虑到特殊情况就不使用else。如果是排序好的，这里使用else可以提高程序性能</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">pre_Node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="c1">//由于已经对最开始的节点进行过判断了，那么下面就从第二个节点开始</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">deleteNum</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pre_Node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">pre_Node</span> <span class="o">=</span> <span class="n">pre_Node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">reverseNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为空</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//将后续节点插入到head和第一个节点之间即可</span>
        <span class="c1">//需要注意迭代的时候没有自增</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="c1">//最后的时候</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//一般情况</span>
            <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printLinkedList</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//是根据节点的值来判断这个节点是偶数还是奇数</span>
<span class="kt">void</span> <span class="nf">oddEvenDivide</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"当前链表为空</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">odd_head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">odd_tail</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">even_head</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">even_tail</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//偶数</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">even_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
                    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                    <span class="n">even_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                    <span class="n">even_tail</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
                    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                    <span class="n">even_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                    <span class="n">even_tail</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">//奇数</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">odd_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
                    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                    <span class="n">odd_head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                    <span class="n">odd_tail</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span><span class="p">));</span>
                    <span class="n">temp</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                    <span class="n">odd_tail</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                    <span class="n">odd_tail</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"奇数节点链表内容为: "</span><span class="p">);</span>
        <span class="n">printLinkedList</span><span class="p">(</span><span class="n">odd_head</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"偶数节点链表内容为: "</span><span class="p">);</span>
        <span class="n">printLinkedList</span><span class="p">(</span><span class="n">even_head</span><span class="p">);</span>
        
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 这个函数的作用是迭代删除，不使用循环删除是因为如果释放了一个节点的空间，
    那么下一个节点的地址就需要一个指针变量来存储。
    使用函数迭代的话，最开始释放的是链表中最后一个节点，然后逐步往前 */</span>
<span class="kt">void</span> <span class="nf">freeNode</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">freeNode</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">free</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//写两个函数一方面是函数名规范一些，另一方面参数名依旧可以是头节点，比较容易理解。</span>
<span class="kt">void</span> <span class="nf">freeLinkedList</span><span class="p">(</span><span class="k">struct</span> <span class="n">Node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">freeNode</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="cm">/*如果不将head-&gt;next设置为空，那么使用head-&gt;next的时候会去访问之前存储的地址，
    但是由于这个地址已经被回收了，在系统允许程序访问的内存空间之外，
    那么在某些情况下（比如打印链表的时候），会报出Segmentation fault: 11的错误而退出程序*/</span>
    <span class="c1">//不释放head是因为后续还要用</span>
    <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

        </div>
    </body>
</html>
