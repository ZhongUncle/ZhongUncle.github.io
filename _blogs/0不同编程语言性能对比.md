---
layout: article
category: Research
date: 2023-03-31
title: 不同编程语言性能对比
---
<!-- excerpt-start -->
一直很好奇不同语言之间的性能对比到底是什么样的，因为很多地方都在强调不同语言之间的性能区别，但是自己又没有实际感受，所以就想做一些实验来了解一下情况。

当然这个实验是没法一次做完的，毕竟我并不能一次性列出自己想做的所有测试项目，而且可能还会有新的语言加入，甚至是加入汇编语言作为基准，以及脚本语言作为对比。所以这可能是一个时间跨度很长的项目。

## 关于数据和测试的一些情况
### 各语言编译器或框架版本

|语言|编译器版本|
|-|-|
|C/C++|Apple clang version 14.0.0 (clang-1400.0.29.102)|
|Java|javac 19.0.1|
|Go|go version go1.20.2 darwin/amd64|
|Swift|Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)|
|Python3|Python 3.9.10|


### 测试设备信息

<img alt="测试设备为 Mac mini 2018 i5 32GB 512GB" src="/assets/images/6f2d7d1340f9bf31c514e309bbcadf45.png" style="box-shadow: 0px 0px 0px 0px">


### 主要看哪个时间呢
记录时间是使用`time`命令统计其运行时间。由于一些程序运行时间太短，可以跑三次及以上，取中间值或者最常出现的值。

`time`返回内容如下：

```bash
real	0m22.944s
user	0m22.922s
sys	0m0.011s
```

`real`指的是 CPU 的时钟时间（clock time），又被称为墙时钟时间（wall clock time），也就是 CPU 实际运行了多久。这个值的高低取决于系统中正在运行的进程的数量。

`user`指的是用户指令使用 CPU 的时间，也就是程序指令花的时间。

`sys`指的是系统内核花在操作进程的 CPU 时间，比如进程使用了`read`这个系统服务，那么时间会算在这里。

由于是为了测试编程语言，除非使用了一些系统调用，或者是一些脚本语言，主要看`user`部分即可。

### 时间之和不对
但是由于存在四舍五入以及调度问题（主要是调度问题），会存在将用户时长和系统时长加起来不等于实际时长（real time）的情况。

### 第一次运行时间显示不稳定
有些语言的测试结果有一个很有意思的地方，第一次记录的总时长会很大（不是误差的程度），但是用户时长和系统时长都是正常的，所以忽略第一次运行的结果。这是进程调度和优先级导致的。

### Swift使用调用函数的方式
Swift 使用调用函数的方式，因为是否使用函数来处理会导致性能有可能十倍的差距，如下是轻度循环测试的两种情况下的结果（运行了十几次，确保不是误差导致的）：

|Swift是否使用函数|CPU时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|不使用函数|0.286|0.283|0.001|
|使用函数|0.029|0.026|0.001|

## 循环测试
一般来说，循环语句是由跳转指令（一般是带判断的跳转指令）和一些其他指令构成的。而且像`while`、`for`这样的循环语句的使用率也很高，也是很多代码运行长时间运行的原因之一。

### 轻度循环测试（单纯测一下循环速度）
第一个项目是对不同编程语言进行1000000（一千万）次`while`循环和自增，并且打印出最后的和。由于每次循环的操作简单，就算是循环了一千万次，但还只是一种轻度测试，代表性不强，只是为了测试对比一下各语言的循环快慢。

这里之所以 Swift 使用`while`循环,是因为 Swift 使用的 For-In 在简单的循环上要比 While 慢得多，因为设计目的是为了遍历数组之类的数据结构。

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|0.020|0.018|0.001|
|Java|0.053|0.031|0.021|
|Go|0.007|0.004|0.002|
|Swift|0.029|0.026|0.001|
|Python3|0.837|0.827|0.009|

可以看到所有编程语言都大幅领先脚本语言。在这次测试中，Go 语言甚至比 C/C++ 还快（加大循环次数，快的比例还是一样）。这个速度真的是有点惊喜，查阅了一些资料发现，Go 在轻度任务里确实非常快。

下面是各语言的代码参见仓库 Language_Benchmark（还未公开）。


### 中度循环测试（Lomuto-Partition 快速排序）
中度的测试就得加强每次循环中的操作了，也比较贴近现实中的情况。那么可以来写一个快速排序进行测试，使用 Lomuto-Partition 方法，然后输出排序结果。

测试数据如下，35 个整数：

```
1272, 1697, 3180, 1653, 2652, 521, 3278, 2589, 904, 702, 3582, 2447, 2435, 777, 440, 1565, 389, 907, 2357, 252, 3643, 1055, 1390, 1110, 609, 3768, 315, 2286, 2687, 818, 2731, 496, 2946, 1133, 84
```

根据 Swift Playground 显示，迭代了 202 次，所有划分数组函数中的 while 语句累计执行了 2313 次：

<img alt="根据 Swift Playground 显示，循环了 202 次" src="/assets/images/6acb96738d55b4fffa93e4e5da0cc41f.png" style="box-shadow: 0px 0px 0px 0px">

结果如下：

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|0.003|0.001|0.001|
|Java|0.061|0.043|0.022|
|Go|0.004|0.002|0.002|
|Swift|0.007|0.002|0.002|
|Python3|0.031|0.020|0.009|

这里由于 C/C++ 运行时间太短了，几乎还没跑起来就完了。所以加大数量，使用 2000 个整数排序，由于 Python 有迭代次数限制，以及 Java 时间较长，就不测试 Python 和 Java 了，只测试 C/C++、Go 和 Swift。

结果如下：

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|2.153|2.149|0.003|
|Go|31.263|32.427|0.724|
|Swift|22.944|22.922|0.011|

结果 C/C++ 还是没用多久就跑完了。可以看到，在上了一些强度之后，C/C++ 展现出了高性能的一面，能比其他语言快 10～15 倍。

本来想看看能有多少次循环，结果 Swift Playground 用了很长时间和很多内存还没跑完：

![Swift Playground 用了很长时间和很多内存还没跑完](/assets/images/ac61c9a01dcf8f45f86c34ab35a0d2fb.png)

所以就换一种方法，我给上面三处地方加了计数（就是三处数不一样的地方），这样就可以加快速度。

最后得到的数据是：迭代 663040 次，所有划分数组函数中的 while 语句累计执行了 442360097 次（快 4.5 亿次，万幸没继续用 Swift Playground 跑）。如果统计所有的加法（不含减法），比如自增、相加的情况，那么总计有 886695669 次（约 8.87 亿次）加法计算。

目前看下来，Swift 作为 C 语言的继承者真的挺不错的，性能和语法都比较均衡，不像 Go 有时突出，有时难用性能又差。下次好好测试一下 Go 的并发能力，Go 只用来写并发程序即可。

#### Swift 在 A13（iPhone 11 Pro）上的测试结果

突然想起可以在 iPhone/iPad 上测试 Swift 编写的程序，但是由于 iPad 和 Xcode 版本不匹配，所以只用 iPhone 进行测试。

iPhone 的测试结果很有意思，如下：

|情况|时长（秒）|
|-|-|
|第一次|29.050|
|第一次之后|0.170|

可以看到，iPhone，或者说 iOS 是有一些机制防止重复计算来浪费性能。


### 重度循环测试
还没想好测什么，等汇编部分出来再测吧