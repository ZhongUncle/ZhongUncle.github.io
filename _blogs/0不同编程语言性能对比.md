---
layout: article
category: Research
date: 2023-03-31
title: 不同编程语言性能对比
---
<!-- excerpt-start -->
突然好奇不同语言之间的性能对比，比较很多地方都在强调不同语言之间的性能区别，但是自己又没有实际感受，所以就想做一些实验来看看实际情况。当然这个实验是没法一次做完的，毕竟我并不能一次性列出自己想做的所有测试项目，而且可能还会有新的语言加入，甚至是加入汇编语言作为基准，以及脚本语言作为对比。所以这可能是一个时间跨度很长的项目。

## 关于数据和测试的一些情况
### 各语言编译器或框架版本

|语言|编译器版本|
|-|-|
|C/C++|Apple clang version 14.0.0 (clang-1400.0.29.102)|
|Java|javac 19.0.1|
|Go|go version go1.20.2 darwin/amd64|
|Python3|Python 3.9.10|
|Swift|Apple Swift version 5.7 (swiftlang-5.7.0.127.4 clang-1400.0.29.50)|

### 测试设备信息




### 主要看哪个时间呢
记录时间是使用`time`命令统计其运行时间。由于一些程序运行时间太短，可以跑三次及以上，取中间值或者最常出现的值。

`time`返回内容如下：

```bash
real	0m22.944s
user	0m22.922s
sys	0m0.011s
```

`real`指的是 CPU 的时钟时间（clock time），又被称为墙时钟时间（wall clock time），也就是 CPU 实际运行了多久。这个值的高低取决于系统中正在运行的进程的数量。

`user`指的是用户指令使用 CPU 的时间，也就是程序指令花的时间。

`sys`指的是系统内核花在操作进程的 CPU 时间，比如进程使用了`read`这个系统服务，那么时间会算在这里。

由于是为了测试编程语言，除非使用了一些系统调用，或者是一些脚本语言，主要看`user`部分即可。

### 时间之和不对
但是由于存在四舍五入以及调度问题（主要是调度问题），会存在将用户时长和系统时长加起来不等于实际时长（real time）的情况。

### 第一次运行时间显示不稳定
有些语言的测试结果有一个很有意思的地方，第一次记录的总时长会很大（不是误差的程度），但是用户时长和系统时长都是正常的，所以忽略第一次运行的结果。这是进程调度和优先级导致的。

### Swift使用调用函数的方式
Swift 使用调用函数的方式，因为是否使用函数来处理会导致性能有可能十倍的差距，如下是轻度循环测试的两种情况下的结果（运行了十几次，确保不是误差导致的）：

|Swift是否使用函数|CPU时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|不使用函数|0.286|0.283|0.001|
|使用函数|0.029|0.026|0.001|

## 循环测试
一般来说，循环语句是由跳转指令（一般是带判断的跳转指令）和一些其他指令构成的。而且像`while`、`for`这样的循环语句的使用率也很高，也是很多代码运行长时间运行的原因之一。

### 轻度循环测试
第一个项目是对不同编程语言进行1000000（一千万）次`while`循环和自增，并且打印出最后的和。由于每次循环的操作简单，就算是循环了一千万次，但还只是一种轻度测试，代表性不强。

这里之所以 Swift 使用`while`循环,是因为 Swift 使用的 For-In 在简单的循环上要比 While 慢得多，因为设计目的是为了遍历数组之类的数据结构。

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|0.020|0.018|0.001|
|Java|0.053|0.031|0.021|
|Go|0.007|0.004|0.002|
|Swift|0.029|0.026|0.001|
|Python3|0.837|0.827|0.009|

可以看到所有编程语言都大幅领先脚本语言。在这次测试中，Go 语言甚至比 C/C++ 还快（加大循环次数，快的比例还是一样）。这个速度真的是有点惊喜，查阅了一些资料发现，Go 在轻度任务里确实非常快。

下面是各语言代码：
C/C++：

```cpp
#include <iostream>

int main() {
	int j = 0;
    for (int i=0; i<10000000; i++) {
        j++;
    }
    
	std::cout<<j<<std::endl;
    
	return 0;
}
```

Java：

```java
public class test {
    public static void main(String[] argv) {
        int j = 0;
        for (int i=0; i<10000000; i++) {
            j++;
        }
        System.out.println(j);
    }
}
```

Go：

```java
package main

import "fmt"

func main() {
	j := 0
	for i := 0; i < 10000000; i++ {
		j++
	}
	
	fmt.Println(j)
}
```

Swift:

```swift
func loop() {
    var i = 0
    var j = 0

    while i < 10000000 {
        i += 1
        j += 1
    }

    print(j)
}

loop()
```

Python：

```python
#!/usr/bin/python3
 
j = 0

for number in range(0, 10000000):
    j=j+1

print(j)
```



### 中度循环测试（Lomuto-Partition 快速排序）
中度的测试就得加强每次循环中的操作了。那么可以来写一个快速排序进行测试，使用 Lomuto-Partition 方法，然后输出排序结果。

测试数据如下，35 个整数：

```
1272, 1697, 3180, 1653, 2652, 521, 3278, 2589, 904, 702, 3582, 2447, 2435, 777, 440, 1565, 389, 907, 2357, 252, 3643, 1055, 1390, 1110, 609, 3768, 315, 2286, 2687, 818, 2731, 496, 2946, 1133, 84
```

根据 Swift Playground 显示，迭代了 202 次，所有划分数组函数中的 while 语句累计执行了 2313 次：

<img alt="根据 Swift Playground 显示，循环了 202 次" src="/assets/images/6acb96738d55b4fffa93e4e5da0cc41f.png" style="box-shadow: 0px 0px 0px 0px">

结果如下：

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|0.003|0.001|0.001|
|Java|0.061|0.043|0.022|
|Go|0.004|0.002|0.002|
|Python3||||
|Swift|0.007|0.002|0.002|

这里由于 C/C++ 运行时间太短了，几乎还没跑起来就完了。所以加大数量，使用 2000 个整数排序，由于一些语言的时间本身就长，就不做测试了，只测试 C/C++、Go 和 Swift。结果如下：

|语言|实际时长（秒）|用户时长（秒）|系统时长（秒）|
|-|-|-|-|
|C/C++|2.153|2.149|0.003|
|Go|31.263|32.427|0.724|
|Swift|22.944|22.922|0.011|

本来想看看能有多少次循环，结果 Swift Playground 用了很长时间和很多内存还没跑完：

![Swift Playground 用了很长时间和很多内存还没跑完](/assets/images/ac61c9a01dcf8f45f86c34ab35a0d2fb.png)

所以就换一种方法，我给上面三处地方加了计数（就是三处数不一样的地方），这样就可以加快速度。

最后得到的数据是：迭代 663040 次，所有划分数组函数中的 while 语句累计执行了 442360097 次（万幸没继续用 Swift Playground 跑）。